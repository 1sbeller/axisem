#############################################################################
############ INPUT FILE FOR AXISEM PYTHON INTERFACE (PyAxi.py) ##############
#############################################################################

# ATTENTION: This file should be located in the same directory as PyAxi.py

# All the options for running AXISEM are included here. 
# However, for simplicity, it has been divided into the following sections:
# 1.  GENERAL: contains very basic options for running AXISEM. 
# 2.  MESHER_BASIC
# 3.  SOLVER_BASIC
# 4.  SOURCE_INFO
# 5.  STATION_INFO
# 6.  POST_PROCESSING
# 7.  MESHER_ADVANCED
# 8.  SOLVER_ADVANCED
# 9.  MPI_NETCDF
# 10. MISC
# 11. TEST
#
#[GENERAL]
#[MESHER_BASIC]
#[SOLVER_BASIC]
#[SOURCE_INFO]
#[STATION_INFO]
#[POST_PROCESSING]
#[MESHER_ADVANCED]
#[SOLVER_ADVANCED]
#[MPI_NETCDF]
#[MISC]
#[TEST]
#
#
[general]
address = ..                             ; address where AXISEM is located
mesh_name = developing_MESHER           ; Name for the mesh folder
solver_name = developing_SOLVER         ; Name for the solver folder
verbose = Y                              ; for debugging purposes

# IMPORTANT:
# 'new_mesh' flag controls all the required steps that you want for your simulation: 
# (except for post_processing and test)

# Y: means that you want to run the AXISEM for a new mesh! (so MESHER and SOLVER)
# N: to re-run the solver with different parameters but the same mesh (so SOLVER) ---> obviously you need an old mesh!
# M: if you change the flag to M, you have a full control on all steps (please refer to the bottom of this section!)

new_mesh = Y                             
post_processing = Y                      ; perform the post processing step

# ATTENTION: if you change the 'new_mesh' flag to 'M' [Manual] 
# you could change these flags in a way that you want
mesher = N                               ; to run the mesher
solver = N                               ; to run the solver
mesher_makefile = Y                      ; Create Mesher Makefile? (just once!)
mesher_make = Y                          ; Run make clean; make for mesher
mesher_move = Y                          ; Run movemesh.csh
solver_makefile = Y                      ; Create Solver Makefile?
solver_cp = Y                            ; defines the mesh as a header
solver_make = Y                          ; Run make clean; make for mesher

[mpi_netCDF]
make_flag = gfortran                     ; add required flags to makemake.pl
mpi_compiler = mpif90 -O3 -fbacktrace    ; mpi compiler of your local machine

netCDF = N                            
# include folder of where the libnetcdff.a is located (type locate libnetcdff.a)
netCDF_LIBS = -lm -L $(HOME)/local/lib -lnetcdff -Wl,-rpath,$(HOME)/local/lib
netCDF_INCLUDE = -I $(HOME)/local/include -I /usr/include

[mesher]
model = 'prem_ani'                       ; Background model: prem,prem_solid etc
period = 40.                              ; DOMINANT period [s]
no_proc = 1                             ; Number of processors to be used
vtk_output = .false.                     ; write vtk output (may cause memory problem for high frequencies (~2s))

[solver]
simu_type = single                       ; type of simulation (single, force, moment)
out_data = ./Data
out_info = ./Info
mesh_test = false
kernel_wavefield = false
kernel_spp = 8
kernel_src = mask
kernel_ibeg = 1
kernel_iend = 1
NR_LIN_SOLIDS = 5
F_MIN = 0.001
F_MAX = 1.0
SAVE_ENERGY = .false.
HOMO_MODEL = .false.
HOMO_VP = 10.
HOMO_VS = 5.77
HOMO_RHO = 3.
FORCE_ANISO = .true.

no_simu = 1                              ; number of simulations. 1: single Mij/f_i; 2: forces; 4: moment tensor
seis_length = 600.                      ; seismogram length [s]
time_step = 0.0                          ; time step [s]. Put to 0.0 to use mesher's suggestion (mesh_params.h)
time_scheme = newmark2                   ; time scheme: newmark2,symplec4,ML_SO4m5,ML_SO6m7,KL_O8m17,SS_35o10
source_type = sourceparams                   ; source file type: 'sourceparams','cmtsolut'
receiver_type = stations                 ; receiver file type: 'colatlon','stations','database'
save_XDMF = .false.                      ; save XDMF files (high resolution 2D wavefields), more options in inparam_xdmf
force_aniso = .false.                    ; force anisotropic model handling
viscoelastic_attenuation = .false.       ; include viscoelastic attenuation

#-----------------------------------------------------------------------
# sourceparams parameters: (not valid for CMTSOLUTION)
sourceparams_type = 'monopole'      ; excitation type: 'monopole', 'dipole', 'quadpole'
sourceparams_MDQ = 'explosion'
# 'explosion','mxx_p_myy','mzz','vertforce' (MONOPOLE)
# 'mxz', 'myz', 'xforce', 'yforce'          (DIPOLE)
# 'mxy', 'mxx_m_myy'                        (QUADRUPOLE)

src_Mzz = 1.E20
src_Mxx = 1.E20
src_Myy = 1.E20
src_Mxz = 0.E20
src_Myz = 0.E20
src_Mxy = 0.E20

source_dp = 100.                         ; source depth [km]
source_colat = 0.0                       ; source colatitude [degrees]
source_lon = 0.0                         ; source longitude [ldegrees]
source_stf = 'dirac_0'                   ; source time function
#-----------------------------------------------------------------------
# cmtsolut parameters: (not valid for sourceparams)
cmt_STF = dirac_0                        ; 'dirac_0', 'quheavi', 'gauss_0', 'gauss_1' (1st deriv), 'gauss_2' (2nd), 'heavis' 

cmt_lat = 90                           ; source latitude [degrees]
cmt_lon = 0                            ; source longitude [degrees]
cmt_dp = 0                             ; source depth [km]

cmt_Mrr = 1.0e+27                     ; Mrr component
cmt_Mtt = 1.0e+27                     ; Mtt component
cmt_Mpp = 1.0e+27                     ; Mpp component
cmt_Mrt = 0.                          ; Mrt component
cmt_Mrp = 0.                          ; Mrp component
cmt_Mtp = 0.                          ; Mtp component

[post_processing]
post_rotate = .true.                     ; rotate receivers?
post_components = 'enz'                  ; receiver components: enz,sph,cyl,xyz,src
post_full_Mij = .true.                   ; sum to full Mij
post_conv_period = 0.                    ; convolve period (0. if not convolved)
post_STF = 'gauss_0'                     ; source time function type for convolution
post_dv = disp                           ; disp or velo seismograms

post_Mrr = N                             ; Mrr
post_Mtt = N                             ; Mtt
post_Mpp = N                             ; Mpp
post_Mrt = N                             ; Mrt
post_Mrp = N                             ; Mrp
post_Mtp = N                             ; Mtp

post_Scolat = N                          ; Source colatitude
post_Slon = N                            ; Source longitude
post_snap = N                            ; plot global snaps?
post_path = N                            ; Directory for post processed data
post_negative = N                        ; seismograms at negative time (0 at max. of stf)

[MISC]
mseed = Y                                ; convert the seismograms into MSEED format
mseed_all = N                            ; convert the seismograms into MSEED format

convSTF = N                              ; after converting the seismograms into MSEED, convolve with STF
halfduration = 5.0                       ; halfduration (do not confuse that with halfduration in the test_section)

filter = N                               ; if you want to appy a filter (lowpass and highpass as defined below)
fmin = 0.012                             ; minimum frequency
fmax = 0.1                               ; maximum frequency

[testing]
# Parameters required for the TESING directoryi
# for running the tests automatically please refer to test_axisem.py
test = N                                 ; if you want to test AXISEM?
test_folder = ./automated/test_99        ; address of the test folder
plot = Y                                 ; to just plot the test waveforms
save_plots = N                           ; save the plots to a file
plot_format = png                        ; file format of the plots
chans = ['Z', 'N']                       ; required channels
fmin = 0.0005                            ; minimum frequency
fmax = 0.02                              ; maximum frequency
halfduration = 20.                       ; halfduration for the Source Time Function
nstat = 20
