module nc_routines
  use global_parameters
contains

!##################################################################################
! Netcdf routines by S. Stähler
!##################################################################################

  subroutine check(status)
  ! Translates netcdf error codes into error messages
    use netcdf
    implicit none
    integer, intent ( in) :: status
    if(status /= nf90_noerr) then 
      print *, trim(nf90_strerror(status))
      stop "Stopped"
    end if
  end subroutine check  


subroutine nc_dump_field_1d(f,flen,varname,appisnap)
  use netcdf
  use data_proc, ONLY : mynum
  use data_io, ONLY   : nc_1d_dimid, nc_proc_dimid, ncid_out 
  implicit none
  integer, intent(in)                :: flen
  real(kind=realkind), intent(in) :: f(flen)
  character(len=*), intent(in)      :: varname
  character(len=4), intent(in)      :: appisnap
  integer                           :: nc_varid
  integer                           :: nc_f_dimid
  integer                           :: status, isnap_loc
  ! Check whether this Variable already exists in file ncid_out
  status =  nf90_inq_varid(ncid_out, trim(varname), nc_varid)
  print*, flen, appisnap, trim(varname)
  read(appisnap,*) isnap_loc

  if (status /= nf90_NoErr) then
    call check( nf90_redef(ncid_out))
    call check( nf90_def_dim(ncid_out, trim(varname), len=flen, dimid=nc_f_dimid) )
    call check( nf90_def_var(ncid_out, trim(varname), NF90_FLOAT, (/nc_f_dimid, nc_proc_dimid, nc_1d_dimid/), nc_varid) )
    call check( nf90_enddef(ncid_out))
  end if

  call check( nf90_put_var(ncid_out, nc_varid, start=(/1, mynum+1, isnap_loc+1/), count=(/flen, 1, 1/), values=f) )
  
end subroutine nc_dump_field_1d

!----------------------------------------------------------------------------
subroutine define_netcdf_output
!
! Creates the netcdf output file for wavefields and defines the dimension 
! nc_1d_dimid, as unlimited.
!
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    use data_io
    use netcdf
    use data_proc 
    
    
!    character(len=16) nc_filename

!    nc_filename = datapath(1:lfdata)
    print *, 'Preparing netcdf file for ', nproc, ' processors'
    call check( nf90_create ( path=datapath(1:lfdata)//"/wavefield_out.nc4", &
      & cmode=nf90_CLOBBER+nf90_hdf5, &
      & ncid=ncid_out, comm = MPI_COMM_WORLD, info = MPI_INFO_NULL)) 
    call check( nf90_def_dim( ncid_out, "snapshots", NF90_UNLIMITED, nc_1d_dimid) )
    call check( nf90_def_dim( ncid_out, "processors", nproc, nc_proc_dimid) )
    call check( nf90_enddef ( ncid_out))

end subroutine

!============================================================================
subroutine end_netcdf_output
! 
!  Closes the netcdf output files
!
!============================================================================
  use data_io
  use netcdf

  call check( nf90_close(ncid_out))

end subroutine
!#####################################################################################
!End of S. Stähler's netcdf routines
!#####################################################################################

!!!!!!!!!AUXUILIAR----------------------------------------NETCDF----------!!!!!!!
subroutine dump_matrix_ncdf(valore,ishot,rows,cols,filename)
implicit none
character(len=50), intent(in)              :: filename
integer,intent(in) :: rows,cols,ishot
real*4,dimension(rows,cols),intent(in) :: valore

write(6,*)'computing nc file ',trim(filename),' ...'
if(ishot==1) then
  call init_ncdf_matrix(ishot,trim(filename),valore,rows,cols)
else
  call write_ncdf_matrix(ishot,trim(filename),valore,rows,cols)
endif
end subroutine dump_matrix_ncdf

!!!!!!!!!AUXUILIAR----------------------------------------NETCDF----------!!!!!!!
subroutine init_ncdf_matrix(ishot,filename,u,rows,cols)
use netcdf
implicit none

integer :: ishot,i
character (len = *) :: filename
integer, parameter :: NDIMS = 3;
integer :: rows,cols
character (len = *), parameter :: U_NAME = "data"
character (len = *), parameter :: REC_NAME = "time"
character (len = *), parameter :: UNITS1 = "values"
character (len = *), parameter :: UNITS2 = "component"
integer :: ncid, varid, dimids(NDIMS)
integer :: u1_dimid,u2_dimid,t_dimid
integer :: start(NDIMS), count(NDIMS)
real*4, dimension(rows,cols):: u

 call check(nf90_create(filename,NF90_SHARE, ncid))
 call check(nf90_def_dim(ncid,UNITS1,rows,u1_dimid))
 call check(nf90_def_dim(ncid,UNITS2,cols,u2_dimid))
 call check(nf90_def_dim(ncid,REC_NAME,NF90_UNLIMITED,t_dimid))
 dimids=(/u1_dimid, u2_dimid, t_dimid/)
 call check(nf90_def_var(ncid,U_NAME,NF90_REAL,dimids,varid))
 call check(nf90_enddef(ncid))
 count = (/rows,cols,1/)
 start = (/1,1,1/)
 call check(nf90_put_var(ncid,varid,u,start=start,count=count));
 call check(nf90_close(ncid)) 

contains
  subroutine check(status)
    integer, intent ( in) :: status
    
    if(status /= nf90_noerr) then 
      print *, trim(nf90_strerror(status))
      stop 2
    end if
  end subroutine check  
end subroutine init_ncdf_matrix

!!!---------------------------------------------------------------------!!!!!
subroutine write_ncdf_matrix(ishot,filename,u,rows,cols)
use netcdf
implicit none
integer :: ishot,i
character (len = *):: filename
character (len = *), parameter :: U_NAME = "data"
integer, parameter :: NDIMS = 3;
integer :: rows,cols,ncid,varid
integer :: start(NDIMS), count(NDIMS)
real*4, dimension(rows,cols)::u

 call check(nf90_open(filename,NF90_WRITE, ncid))
	call check(nf90_inq_varid(ncid,U_NAME,varid))
 count = (/rows,cols,1/)
 start = (/1,1,ishot/)
 call check(nf90_put_var(ncid,varid,u,start=start,count=count));
 call check(nf90_close(ncid))

!	write(6,*) 'shot:',ishot,'ncid:',ncid,'varid',varid

contains
  subroutine check(status)
    integer, intent ( in) :: status
    
    if(status /= nf90_noerr) then 
      print *, trim(nf90_strerror(status))
      stop 2
    end if
  end subroutine check  
end subroutine write_ncdf_matrix


end module nc_routines
