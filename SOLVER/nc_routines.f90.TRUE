module nc_routines
  use global_parameters
contains

!##################################################################################
! Netcdf routines by S. St√§hler
!##################################################################################

  subroutine check(status)
  ! Translates netcdf error codes into error messages
    use netcdf
    implicit none
    integer, intent ( in) :: status
    if(status /= nf90_noerr) then 
      print *, trim(nf90_strerror(status))
      stop 1
    end if
  end subroutine check  

!******************************************************************************************************

subroutine nc_dump_field_1d(f,flen,varname,appisnap)
  use netcdf
  use data_proc, ONLY : mynum
  use data_io, ONLY   : ncid_out, ncid_snapout
  implicit none
  integer, intent(in)                :: flen
  real(kind=realkind), intent(in) :: f(flen)
  character(len=*), intent(in)      :: varname
  character(len=4), intent(in)      :: appisnap
  integer                           :: nc_varid
  !integer                           :: nc_f_dimid
  integer                           :: status, isnap_loc
  ! Check whether this Variable already exists in file ncid_out
!  status =  nf90_inq_varid(ncid_out, trim(varname), nc_varid)
  write(6,*) flen, appisnap, trim(varname), ncid_out

  call check( nf90_inq_varid(ncid_snapout, trim(varname), nc_varid) )

  read(appisnap,*) isnap_loc

!  if (status /= nf90_NoErr) then
!    call check( nf90_redef(ncid_out))
!    call check( nf90_def_dim(ncid_out, trim(varname), len=flen, dimid=nc_f_dimid) )
!    call check( nf90_def_var(ncid_out, trim(varname), NF90_FLOAT, (/nc_f_dimid, nc_proc_dimid, nc_1d_dimid/), nc_varid) )
!    call check( nf90_enddef(ncid_out))
!  end if

  call check( nf90_put_var(ncid_snapout, nc_varid, start=(/1, mynum+1, isnap_loc+1/), count=(/flen, 1, 1/), values=f) )
  
end subroutine nc_dump_field_1d
!******************************************************************************************************
subroutine nc_dump_rec(recfield, nc_varid, nrec, dim2, idump)
  use netcdf
  use data_io 
  use data_mesh, ONLY: loc2globrec
  use data_proc, ONLY : mynum
  implicit none
  integer, intent(in)                          :: nrec, dim2, idump, nc_varid
  real(kind=realkind), intent(inout), dimension(nrec,dim2) :: recfield
  integer                                      :: irec
  
  do irec = 1, nrec
    !write(6,*) idump, irec, loc2globrec(irec), mynum
    !flush(6)
    call check( nf90_put_var(ncid_recout, nc_varid, start=(/idump, 1, loc2globrec(irec)/), &
              & count = (/1, dim2, 1/), values=recfield(irec,:)) )
  end do

end subroutine

!******************************************************************************************************
subroutine nc_dump_rec_perproc(recfield, nc_varid, nrec, dim2, idump)
  use netcdf
  use data_io 
  use data_proc, ONLY: mynum
!  use data_mesh, ONLY: loc2globrec
  implicit none
  integer, intent(in)                          :: nrec, dim2, idump, nc_varid
  real(kind=realkind), intent(inout), dimension(nrec,dim2) :: recfield
  integer                                      :: irec
  
!  write(6,*) flen, appisnap, trim(varname), ncid_out

  do irec = 1, nrec
    !write(6,*) nc_varid, idump, irec, mynum
    call check( nf90_put_var(ncid_recout, nc_varid, start=(/idump, 1, irec, mynum+1/), &
              & count = (/1, dim2, 1, 1/), values=recfield(irec,:)) )
  end do

end subroutine
!******************************************************************************************************
subroutine nc_define_receiverfile(nrec, rec_names, rec_th, rec_th_req, &
 &  rec_ph, rec_proc)

  use data_io
  use data_proc, ONLY: nproc, mynum 
  use data_time, ONLY: niter, strain_it
  use netcdf
  use data_mesh, ONLY: maxind
!    use commpi
  implicit none

  integer, intent(in)                         :: nrec 
  character(len=40),intent(in)                :: rec_names(nrec)
  real(8), dimension(nrec),intent(in) :: rec_th, rec_th_req, rec_ph
  integer, dimension(nrec),intent(in) :: rec_proc
  integer  :: irec
  integer  :: nc_latr_varid, nc_lon_varid, nc_lat_varid,  nc_ph_varid
  integer  :: nc_thr_varid, nc_th_varid, nc_proc_varid, nc_recnam_dimid
  integer  :: nc_recnam_varid, nc_surf_dimid
  integer,parameter                  :: nvar=10
  character(len=16), dimension(nvar) :: varname 
  integer                            :: ivar, nc_varid, nc_f_dimid
  
  
  varname = (/'strain_dsus_sol', 'strain_dsuz_sol', 'strain_dpup_sol', &
    &         'straintrace_sol', 'strain_dsus_flu', 'strain_dsuz_flu', &
    &         'strain_dpup_flu', 'straintrace_flu', 'velo_sol       ', &
    &         'velo_flu       '/)
    
  if (mynum.eq.0) then    
    write(6,*) '  Producing groups for Seismograms and Snapshots'
    call check( nf90_def_grp( ncid_out, "Seismograms", ncid_recout) )
    call check( nf90_def_grp( ncid_out, "Snapshots", ncid_snapout) )
    write(6,*) '  Seismograms group has ID', ncid_recout, ', Snapshots group has ID', ncid_snapout
    
    write(6,*) 'Define variables in ''Snapshots'' group of NetCDF output file'
    write(6,*) '  awaiting', floor(real(niter)/real(strain_it)), ' snapshots'
    call check( nf90_def_dim( ncid_snapout, "snapshots", floor(real(niter)/real(strain_it)), nc_snap_dimid) )
    call check( nf90_def_dim( ncid_snapout, "processors", nproc, nc_proc_dimid) )
    do ivar=1,nvar
      call check( nf90_def_dim(ncid_snapout, trim(varname(ivar)), len=NF90_UNLIMITED, dimid=nc_f_dimid) )
      call check( nf90_def_var(ncid_snapout, trim(varname(ivar)), NF90_FLOAT,  &
                & (/nc_f_dimid, nc_proc_dimid, nc_snap_dimid/), nc_varid) )
      write(6,100) trim(varname(ivar)), nc_varid
100   format('  Netcdf variable ',A16,' with ID ', I3, ' produced.')       
    end do
    
    
    write(6,*) 'Define dimensions in ''Seismograms'' group of NetCDF output file'
    write(6,*) '  ''Seismograms'' group has ID ', ncid_recout
!    call check( nf90_open ( path=datapath(1:lfdata)//"/axisem_output.nc4"))   
!    call check( nf_redef(ncid=ncid_out ) )
!    call check( nf90_create ( path=datapath(1:lfdata)//"/seismograms_out.nc4", &
!      & cmode=ior(nf90_CLOBBER,nf90_hdf5), &
!      & ncid=ncid_recout, comm = MPI_COMM_WORLD, info = MPI_INFO_NULL)) 
    call check( nf90_def_dim( ncid_recout, "timesteps", niter, nc_times_dimid) )
    call check( nf90_def_dim( ncid_recout, "receivers", nrec, nc_rec_dimid) )
    call check( nf90_def_dim( ncid_recout, "processors", nproc, nc_recproc_dimid) )
    call check( nf90_def_dim( ncid_recout, "surf_elems", maxind, nc_surf_dimid) ) 
    call check( nf90_def_dim( ncid_recout, "components", 3, nc_comp_dimid) )
    call check( nf90_def_dim( ncid_recout, "recnamlength", 40, nc_recnam_dimid) )
    write(6,*) 'NetCDF dimensions defined'
    
    write(6,*) 'Define variables in ''Seismograms'' group of NetCDF output file'
    call check( nf90_def_var( ncid_recout, "displacement", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_rec_dimid/), nc_disp_varid, &
                &  deflate_level=2) )
    call check( nf90_put_att(ncid_recout, nc_disp_varid, 'units', 'meters') )
    
    call check( nf90_def_var( ncid_recout, "surface_displacement", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_surf_dimid, nc_recproc_dimid/), &
                & nc_surfelem_disp_varid, deflate_level=2 ) )
    call check( nf90_put_att(ncid_recout, nc_surfelem_disp_varid, 'units', 'meters'))
    
    call check( nf90_def_var( ncid_recout, "surface_velocity", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_surf_dimid, nc_recproc_dimid/), &
                & nc_surfelem_velo_varid, deflate_level=2 ) )
    call check( nf90_put_att(ncid_recout, nc_surfelem_velo_varid, 'units', 'meters per second') )
    
    call check( nf90_def_var( ncid_recout, "Lat_req", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_latr_varid) )

    call check( nf90_def_var( ncid_recout, "Lon", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_lon_varid) )
    call check( nf90_def_var( ncid_recout, "Lat", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_lat_varid) )
    call check( nf90_def_var( ncid_recout, "azimuths", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_ph_varid) )
    call check( nf90_def_var( ncid_recout, "distances_requested", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_thr_varid) )
    call check( nf90_def_var( ncid_recout, "distances", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_th_varid) )
    call check( nf90_def_var( ncid_recout, "processor_of_receiver", NF90_INT, &
                & (/nc_rec_dimid/), nc_proc_varid) )
    call check( nf90_def_var( ncid_recout, "receiver_name", NF90_CHAR, &
                  & (/nc_rec_dimid, nc_recnam_dimid/), nc_recnam_varid) )
    write(6,*) 'NetCDF variables defined'
    call check( nf90_enddef ( ncid_out))
    write(6,*) 'Writing station info into NetCDF file'
    call check( nf90_put_var( ncid_recout, nc_th_varid, values = rec_th) )
    call check( nf90_put_var( ncid_recout, nc_ph_varid, values = rec_ph) )
    call check( nf90_put_var( ncid_recout, nc_thr_varid, values = rec_th_req) )
    call check( nf90_put_var( ncid_recout, nc_proc_varid, values = rec_proc) ) 

    !call check( nf90_put_att(ncid_out, NF90_GLOBAL, 'station names', rec_names) )
      do irec=1,nrec
        write(6,*) 'Write name ', rec_names(irec), ' of receiver',irec
        call check( nf90_put_var( ncid_recout, nc_recnam_varid, start = (/irec, 1/),&
        &         count = (/1, 40/), &
        &         values = (rec_names(irec))) )
      end do
    write(6,*) 'done'
    call check( nf90_redef ( ncid_out))
  end if       
end subroutine

subroutine nc_simulation_info



end subroutine


!----------------------------------------------------------------------------
subroutine define_netcdf_output
!
! Creates the netcdf output file for wavefields and defines the dimension 
! nc_1d_dimid, as unlimited.
!
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    use data_io
    use netcdf
    use data_proc, ONLY: nproc
!    use commpi
    implicit none    
!    character(len=16) nc_filename

!    nc_filename = datapath(1:lfdata)
    !if (use_netcdf) then
      write (6,*) 'Preparing netcdf file for ', nproc, ' processors'
      call check( nf90_create ( path=datapath(1:lfdata)//"/axisem_output.nc4", &
        & cmode=ior(nf90_CLOBBER,nf90_hdf5), &
        & ncid=ncid_out)) !, comm = MPI_COMM_WORLD, info = MPI_INFO_NULL)) 

      write(6,*) 'Netcdf file with ID ',ncid_out,' produced.'
    !end if
!    call check( nf90_close ( ncid_out))
end subroutine
!----------------------------------------------------------------------------

subroutine nc_write_att_char(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*), intent(in)  :: attribute_name, attribute_value
  !write(6,*) 'Writing ', attribute_value, ' to attr. ', attribute_name, ' in netcdf ID', ncid_out
  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_char

!----------------------------------------------------------------------------
subroutine nc_write_att_real(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*),  intent(in)  :: attribute_name
  real, intent(in)                :: attribute_value

  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_real

!----------------------------------------------------------------------------
subroutine nc_write_att_int(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*),  intent(in)  :: attribute_name
  integer, intent(in)                :: attribute_value

  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_int

!subroutine nc_write_att_log(attribute_value, attribute_name)
!  use netcdf
!  use data_io
!  character(len=*),  intent(in)  :: attribute_name
!  logical, intent(in)                :: attribute_value
!
!  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )
!
!end subroutine nc_write_att_log

subroutine nc_open_parallel
  use data_io
  use netcdf
  use data_proc 
  use commpi,      ONLY : MPI_COMM_WORLD, MPI_INFO_NULL
  use commun,      ONLY : barrier
  implicit none
  integer  status 
  if (mynum==0) then
    call check(nf90_close(ncid_out))
    write(6,*) '  Root process closed netCDF file, waiting for all procs to arrive here and then open it for parallel IO'
  end if
  call barrier
  call check( nf90_open ( path=datapath(1:lfdata)//"/axisem_output.nc4", & 
              & mode=NF90_WRITE, ncid=ncid_out, comm = MPI_COMM_WORLD, info = MPI_INFO_NULL))
  write(6,*) '  Proc ', mynum, ' opened file and is ready to rupture'
  call check( nf90_inq_grp_ncid(ncid_out, "Seismograms", ncid_recout) )
  call check( nf90_inq_grp_ncid(ncid_out, "Snapshots", ncid_snapout) )
  call check( nf90_inq_varid( ncid_recout, "displacement", nc_disp_varid) )
  call check( nf90_inq_varid( ncid_recout, "surface_displacement", nc_surfelem_disp_varid ) )
  call check( nf90_inq_varid( ncid_recout, "surface_velocity", nc_surfelem_velo_varid ) )
 

end subroutine

!============================================================================
subroutine end_netcdf_output
! 
!  Closes the netcdf output files
!
!============================================================================
  use data_io, only: ncid_out, ncid_recout
  use netcdf
  integer  status 
  status = nf90_close(ncid_out)
!  status = nf90_close(ncid_recout)
end subroutine

!#####################################################################################
!End of S. St√§hler's netcdf routines
!#####################################################################################

end module nc_routines
