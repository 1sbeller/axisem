module nc_routines
  use global_parameters
contains

!##################################################################################
! Netcdf routines by S. St√§hler
!##################################################################################

  subroutine check(status)
  ! Translates netcdf error codes into error messages
    use netcdf
    implicit none
    integer, intent ( in) :: status
    if(status /= nf90_noerr) then 
      print *, trim(nf90_strerror(status))
      stop 1
    end if
  end subroutine check  

!******************************************************************************************************

subroutine nc_dump_field_1d(f,flen,varname,appisnap)
  use netcdf
  use data_proc, ONLY : mynum
  use data_io, ONLY   : nc_1d_dimid, nc_proc_dimid, ncid_out, ncid_snapout
  implicit none
  integer, intent(in)                :: flen
  real(kind=realkind), intent(in) :: f(flen)
  character(len=*), intent(in)      :: varname
  character(len=4), intent(in)      :: appisnap
  integer                           :: nc_varid
  !integer                           :: nc_f_dimid
  integer                           :: status, isnap_loc
  ! Check whether this Variable already exists in file ncid_out
!  status =  nf90_inq_varid(ncid_out, trim(varname), nc_varid)
  write(6,*) flen, appisnap, trim(varname), ncid_out

  call check( nf90_inq_varid(ncid_snapout, trim(varname), nc_varid) )

  read(appisnap,*) isnap_loc

!  if (status /= nf90_NoErr) then
!    call check( nf90_redef(ncid_out))
!    call check( nf90_def_dim(ncid_out, trim(varname), len=flen, dimid=nc_f_dimid) )
!    call check( nf90_def_var(ncid_out, trim(varname), NF90_FLOAT, (/nc_f_dimid, nc_proc_dimid, nc_1d_dimid/), nc_varid) )
!    call check( nf90_enddef(ncid_out))
!  end if

  call check( nf90_put_var(ncid_snapout, nc_varid, start=(/1, mynum+1, isnap_loc+1/), count=(/flen, 1, 1/), values=f) )
  
end subroutine nc_dump_field_1d
!******************************************************************************************************
subroutine nc_dump_rec(recfield, nc_varid, nrec, dim2, idump)
  use netcdf
  use data_io 
  use data_mesh, ONLY: loc2globrec
  implicit none
  integer, intent(in)                          :: nrec, dim2, idump, nc_varid
  real(kind=realkind), intent(inout), dimension(nrec,dim2) :: recfield
  integer                                      :: irec
  
  do irec = 1, nrec
    call check( nf90_put_var(ncid_recout, nc_varid, start=(/idump, 1, loc2globrec(irec)/), &
              & count = (/1, dim2, 1/), values=recfield(irec,:)) )
  end do

end subroutine

!******************************************************************************************************
subroutine nc_dump_rec_perproc(recfield, nc_varid, nrec, dim2, idump)
  use netcdf
  use data_io 
  use data_proc, ONLY: mynum
!  use data_mesh, ONLY: loc2globrec
  implicit none
  integer, intent(in)                          :: nrec, dim2, idump, nc_varid
  real(kind=realkind), intent(inout), dimension(nrec,dim2) :: recfield
  integer                                      :: irec
  
!  write(6,*) flen, appisnap, trim(varname), ncid_out

  do irec = 1, nrec
    !write(6,*) nc_varid, idump, irec, mynum
    call check( nf90_put_var(ncid_recout, nc_varid, start=(/idump, 1, irec, mynum+1/), &
              & count = (/1, dim2, 1, 1/), values=recfield(irec,:)) )
  end do

end subroutine
!******************************************************************************************************
subroutine nc_define_receiverfile(nrec, rec_names, rec_th, rec_th_req, &
 &  rec_ph, rec_proc)

    use data_io
    use data_proc, ONLY: nproc, mynum 
    use netcdf
    use data_mesh, ONLY: maxind
    use commpi
    implicit none

    integer, intent(in)                         :: nrec 
    character(len=40),intent(in)                :: rec_names(nrec)
    real(8), dimension(nrec),intent(in) :: rec_th, rec_th_req, rec_ph
    integer, dimension(nrec),intent(in) :: rec_proc
    integer  :: irec
    integer  :: nc_latr_varid, nc_lon_varid, nc_lat_varid,  nc_ph_varid
    integer  :: nc_thr_varid, nc_th_varid, nc_proc_varid, nc_recnam_dimid
    integer  :: nc_recnam_varid, nc_surf_dimid
    if (mynum.eq.0) then    
!    call check( nf90_open ( path=datapath(1:lfdata)//"/axisem_output.nc4"))   
!    call check( nf_redef(ncid=ncid_out ) )
!    call check( nf90_create ( path=datapath(1:lfdata)//"/seismograms_out.nc4", &
!      & cmode=ior(nf90_CLOBBER,nf90_hdf5), &
!      & ncid=ncid_recout, comm = MPI_COMM_WORLD, info = MPI_INFO_NULL)) 
    call check( nf90_def_dim( ncid_recout, "snapshots", NF90_UNLIMITED, nc_times_dimid) )
    call check( nf90_def_dim( ncid_recout, "receivers", nrec, nc_rec_dimid) )
    call check( nf90_def_dim( ncid_recout, "processors", nproc, nc_recproc_dimid) )
    call check( nf90_def_dim( ncid_recout, "surf_elems", maxind, nc_surf_dimid) ) 
    call check( nf90_def_dim( ncid_recout, "components", 3, nc_comp_dimid) )
    call check( nf90_def_dim( ncid_recout, "recnamlength", 40, nc_recnam_dimid) )
    if (lpr) write(6,*) 'NetCDF dimensions defined'
    
    call check( nf90_def_var( ncid_recout, "displacement", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_rec_dimid/), nc_disp_varid, &
                &  deflate_level=2) )
    call check( nf90_put_att(ncid_recout, nc_disp_varid, 'units', 'meters') )
    
    call check( nf90_def_var( ncid_recout, "surface_displacement", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_surf_dimid, nc_recproc_dimid/), &
                & nc_surfelem_disp_varid, deflate_level=2 ) )
    call check( nf90_put_att(ncid_recout, nc_surfelem_disp_varid, 'units', 'meters'))
    
    call check( nf90_def_var( ncid_recout, "surface_velocity", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_surf_dimid, nc_recproc_dimid/), &
                & nc_surfelem_velo_varid, deflate_level=2 ) )
    call check( nf90_put_att(ncid_recout, nc_surfelem_velo_varid, 'units', 'meters per second') )
    
    call check( nf90_def_var( ncid_recout, "Lat_req", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_latr_varid) )

    call check( nf90_def_var( ncid_recout, "Lon", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_lon_varid) )
    call check( nf90_def_var( ncid_recout, "Lat", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_lat_varid) )
    call check( nf90_def_var( ncid_recout, "azimuths", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_ph_varid) )
    call check( nf90_def_var( ncid_recout, "distances_requested", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_thr_varid) )
    call check( nf90_def_var( ncid_recout, "distances", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_th_varid) )
    call check( nf90_def_var( ncid_recout, "processor_of_receiver", NF90_INT, &
                & (/nc_rec_dimid/), nc_proc_varid) )
    call check( nf90_def_var( ncid_recout, "receiver_name", NF90_CHAR, &
                  & (/nc_rec_dimid, nc_recnam_dimid/), nc_recnam_varid) )
    if (lpr) write(6,*) 'NetCDF variables defined'
!    call check( nf90_enddef ( ncid_out))
    if (lpr) write(6,*) 'Ending NetCDF define mode'
    

      if (lpr) write(6,*) 'Writing station info into NetCDF file'
      call check( nf90_put_var( ncid_recout, nc_th_varid, values = rec_th) )
      call check( nf90_put_var( ncid_recout, nc_ph_varid, values = rec_ph) )
      call check( nf90_put_var( ncid_recout, nc_thr_varid, values = rec_th_req) )
      call check( nf90_put_var( ncid_recout, nc_proc_varid, values = rec_proc) ) 

!      do irec=1,nrec
!        call check( nf90_put_var( ncid_recout, nc_recnam_varid, start = (/irec+1, 1/),&
!        &         count = (/1, 40/), &
!        &         values = (rec_names(irec))) )
!      end do
      if (lpr) write(6,*) 'done'
    end if       
end subroutine

subroutine nc_simulation_info



end subroutine


!----------------------------------------------------------------------------
subroutine define_netcdf_output
!
! Creates the netcdf output file for wavefields and defines the dimension 
! nc_1d_dimid, as unlimited.
!
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    use data_io
    use netcdf
    use data_proc 
    use commpi
    implicit none    
    integer,parameter                  :: nvar=10
    character(len=16), dimension(nvar) :: varname 
    integer                            :: ivar, nc_varid, nc_f_dimid
    varname = (/'strain_dsus_sol', 'strain_dsuz_sol', 'strain_dpup_sol', &
      &         'straintrace_sol', 'strain_dsus_flu', 'strain_dsuz_flu', &
      &         'strain_dpup_flu', 'straintrace_flu', 'velo_sol       ', &
      &         'velo_flu       '/)
!    character(len=16) nc_filename

!    nc_filename = datapath(1:lfdata)
    if (lpr) write (6,*) 'Preparing netcdf file for ', nproc, ' processors'
    call check( nf90_create ( path=datapath(1:lfdata)//"/axisem_output.nc4", &
      & cmode=ior(nf90_CLOBBER,nf90_hdf5), &
      & ncid=ncid_out)) !, comm = MPI_COMM_WORLD, info = MPI_INFO_NULL)) 


    call check( nf90_def_grp( ncid_out, "Seismograms", ncid_recout) )
    call check( nf90_def_grp( ncid_out, "Snapshots", ncid_snapout) )

    call check( nf90_def_dim( ncid_snapout, "snapshots", NF90_UNLIMITED, nc_1d_dimid) )
    call check( nf90_def_dim( ncid_snapout, "processors", nproc, nc_proc_dimid) )
    do ivar=1,nvar
      call check( nf90_def_dim(ncid_snapout, trim(varname(ivar)), len=NF90_UNLIMITED, dimid=nc_f_dimid) )
      call check( nf90_def_var(ncid_snapout, trim(varname(ivar)), NF90_FLOAT,  &
                & (/nc_f_dimid, nc_proc_dimid, nc_1d_dimid/), nc_varid) )
      if (lpr) write(6,100) trim(varname(ivar)), nc_varid
100   format('  Netcdf variable ',A16,' with ID ', I3, ' produced.')       
    end do
!    call check( nf90_close ( ncid_out))
    if (lpr) write(6,*) 'Netcdf file with ID ',ncid_out,' produced.'
end subroutine
!----------------------------------------------------------------------------

subroutine nc_write_att_char(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*), intent(in)  :: attribute_name, attribute_value

  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_char

!----------------------------------------------------------------------------
subroutine nc_write_att_real(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*),  intent(in)  :: attribute_name
  real, intent(in)                :: attribute_value

  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_real

!----------------------------------------------------------------------------
subroutine nc_write_att_int(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*),  intent(in)  :: attribute_name
  integer, intent(in)                :: attribute_value

  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_int

!subroutine nc_write_att_log(attribute_value, attribute_name)
!  use netcdf
!  use data_io
!  character(len=*),  intent(in)  :: attribute_name
!  logical, intent(in)                :: attribute_value
!
!  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )
!
!end subroutine nc_write_att_log

subroutine nc_open_parallel
  use data_io
  use netcdf
  use data_proc 
  use commpi,      ONLY : MPI_COMM_WORLD, MPI_INFO_NULL
  use commun,      ONLY : barrier
  implicit none
  integer  status 
  if (mynum==0) call check(nf90_close(ncid_out))
  call barrier
  call check( nf90_open ( path=datapath(1:lfdata)//"/axisem_output.nc4", & 
              & mode=NF90_WRITE, ncid=ncid_out, comm = MPI_COMM_WORLD, info = MPI_INFO_NULL))

  call check( nf90_inq_grp_ncid(ncid_out, "Seismograms", ncid_recout) )
  call check( nf90_inq_varid( ncid_recout, "displacement", nc_disp_varid) )
  call check( nf90_inq_varid( ncid_recout, "surface_displacement", nc_surfelem_disp_varid ) )
  call check( nf90_inq_varid( ncid_recout, "surface_velocity", nc_surfelem_velo_varid ) )
 

end subroutine

!============================================================================
subroutine end_netcdf_output
! 
!  Closes the netcdf output files
!
!============================================================================
  use data_io, only: ncid_out, ncid_recout
  use netcdf
  integer  status 
  status = nf90_close(ncid_out)
!  status = nf90_close(ncid_recout)
end subroutine

!#####################################################################################
!End of S. St√§hler's netcdf routines
!#####################################################################################

!!!!!!!!!AUXUILIAR----------------------------------------NETCDF----------!!!!!!!
subroutine dump_matrix_ncdf(valore,ishot,rows,cols,filename)
implicit none
character(len=50), intent(in)              :: filename
integer,intent(in) :: rows,cols,ishot
real*4,dimension(rows,cols),intent(in) :: valore

!write(6,*)'computing nc file ',trim(filename),' ...'
!if(ishot==1) then
!  call init_ncdf_matrix(ishot,trim(filename),valore,rows,cols)
!else
!  call write_ncdf_matrix(ishot,trim(filename),valore,rows,cols)
!endif
end subroutine dump_matrix_ncdf

!!!!!!!!!AUXUILIAR----------------------------------------NETCDF----------!!!!!!!
subroutine init_ncdf_matrix(ishot,filename,u,rows,cols)
use netcdf
implicit none

integer :: ishot,i
character (len = *) :: filename
integer, parameter :: NDIMS = 3;
integer :: rows,cols
character (len = *), parameter :: U_NAME = "data"
character (len = *), parameter :: REC_NAME = "time"
character (len = *), parameter :: UNITS1 = "values"
character (len = *), parameter :: UNITS2 = "component"
integer :: ncid, varid, dimids(NDIMS)
integer :: u1_dimid,u2_dimid,t_dimid
integer :: start(NDIMS), count(NDIMS)
real*4, dimension(rows,cols):: u

 call check(nf90_create(filename,NF90_SHARE, ncid))
 call check(nf90_def_dim(ncid,UNITS1,rows,u1_dimid))
 call check(nf90_def_dim(ncid,UNITS2,cols,u2_dimid))
 call check(nf90_def_dim(ncid,REC_NAME,NF90_UNLIMITED,t_dimid))
 dimids=(/u1_dimid, u2_dimid, t_dimid/)
 call check(nf90_def_var(ncid,U_NAME,NF90_REAL,dimids,varid))
 call check(nf90_enddef(ncid))
 count = (/rows,cols,1/)
 start = (/1,1,1/)
 call check(nf90_put_var(ncid,varid,u,start=start,count=count));
 call check(nf90_close(ncid)) 

end subroutine init_ncdf_matrix

!!!---------------------------------------------------------------------!!!!!
subroutine write_ncdf_matrix(ishot,filename,u,rows,cols)
use netcdf
implicit none
integer :: ishot,i
character (len = *):: filename
character (len = *), parameter :: U_NAME = "data"
integer, parameter :: NDIMS = 3;
integer :: rows,cols,ncid,varid
integer :: start(NDIMS), count(NDIMS)
real*4, dimension(rows,cols)::u

 call check(nf90_open(filename,NF90_WRITE, ncid))
	call check(nf90_inq_varid(ncid,U_NAME,varid))
 count = (/rows,cols,1/)
 start = (/1,1,ishot/)
 call check(nf90_put_var(ncid,varid,u,start=start,count=count));
 call check(nf90_close(ncid))

!	write(6,*) 'shot:',ishot,'ncid:',ncid,'varid',varid

end subroutine write_ncdf_matrix


end module nc_routines
