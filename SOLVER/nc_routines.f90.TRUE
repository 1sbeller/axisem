module nc_routines
  use global_parameters
  real, allocatable :: recdumpvar(:,:,:) 
contains

!##################################################################################
! Netcdf routines by S. St√§hler
!##################################################################################

  subroutine check(status)
  ! Translates netcdf error codes into error messages
    use netcdf
    implicit none
    integer, intent ( in) :: status
    if(status /= nf90_noerr) then 
      print *, trim(nf90_strerror(status))
      stop 1
    end if
  end subroutine check  

!******************************************************************************************************

subroutine nc_dump_field_1d(f,flen,varname,appisnap)
  use netcdf
  use data_proc, ONLY : mynum
  use data_io, ONLY   : ncid_out, ncid_snapout, nc_field_varid, varnamelist, nvar
  implicit none
  integer, intent(in)                :: flen
  real(kind=realkind), intent(in) :: f(flen)
  character(len=*), intent(in)      :: varname
  character(len=4), intent(in)      :: appisnap
  integer                           :: status, isnap_loc, ivar
  ! Check whether this Variable already exists in file ncid_out
!  status =  nf90_inq_varid(ncid_out, trim(varname), nc_varid)
  write(6,*) flen, mynum, appisnap, trim(varname), ncid_out, ncid_snapout

  read(appisnap,*) isnap_loc
  !call check( nf90_inq_varid(ncid=ncid_snapout, name=trim(varname), varid=nc_varid) )

  do ivar = 1, nvar
    if (trim(varnamelist(ivar))==trim(varname)) exit
  end do

!  write(6,90) trim(varname), ivar, nc_field_varid(ivar)
90 format('Found var ', A16, ' in entry', I3, ' with varid ', I6)
  call check( nf90_put_var(ncid=ncid_snapout, varid=nc_field_varid(ivar), &
              start=(/1, mynum+1, isnap_loc/), count=(/flen, 1, 1/), values=f) )
  !write(6,*) 'written'
  
end subroutine nc_dump_field_1d
!******************************************************************************************************
subroutine nc_dump_rec(recfield, nc_varid, nrec, dim2, idump)
  use netcdf
  use data_io 
  use data_mesh, ONLY: loc2globrec
  use data_time, ONLY: niter
  use data_proc, ONLY : mynum
  implicit none
  integer, intent(in)                          :: nrec, dim2, idump, nc_varid
  real(kind=realkind), intent(inout), dimension(nrec,dim2) :: recfield
  integer                                      :: irec
  
  recdumpvar(mod(idump-1,100)+1,:,:) = transpose(recfield(:,:))
  if ((idump*0.01).eq.(niter*0.01)) then
    do irec = 1, nrec
      call check( nf90_put_var(ncid_recout, nc_varid, start=(/idump, 1, loc2globrec(irec)/), &
                & count = (/1, dim2, 1/), values=recfield(irec,:)) )
    end do
  end if
  if (mod(idump,100).eq.0) then 
    do irec = 1, nrec
      call check( nf90_put_var(ncid_recout, nc_varid, start=(/idump-99, 1, loc2globrec(irec)/), &
                & count = (/100, dim2, 1/), values=recdumpvar(:,:,irec) ) )
    end do
  end if

end subroutine

!******************************************************************************************************
subroutine nc_dump_rec_perproc(recfield, nc_varid, nrec, dim2, idump)
  use netcdf
  use data_io 
  use data_proc, ONLY: mynum
!  use data_mesh, ONLY: loc2globrec
  implicit none
  integer, intent(in)                          :: nrec, dim2, idump, nc_varid
  real(kind=realkind), intent(inout), dimension(nrec,dim2) :: recfield
  integer                                      :: irec
  
!  write(6,*) flen, appisnap, trim(varname), ncid_out

  do irec = 1, nrec
    !write(6,*) nc_varid, idump, irec, mynum
    call check( nf90_put_var(ncid_recout, nc_varid, start=(/idump, 1, irec, mynum+1/), &
              & count = (/1, dim2, 1, 1/), values=recfield(irec,:)) )
  end do

end subroutine
!******************************************************************************************************
subroutine nc_define_receiverfile(nrec, rec_names, rec_th, rec_th_req, &
 &  rec_ph, rec_proc)

  use data_io
  use data_proc, ONLY: nproc, mynum 
  use data_time, ONLY: niter, strain_it
  use netcdf
  use data_mesh, ONLY: maxind
!    use commpi
  implicit none
  include 'mesh_params.h'

  integer, intent(in)                         :: nrec 
  character(len=40),intent(in)                :: rec_names(nrec)
  real(8), dimension(nrec),intent(in) :: rec_th, rec_th_req, rec_ph
  integer, dimension(nrec),intent(in) :: rec_proc
  integer  :: irec
  integer  :: nc_latr_varid, nc_lon_varid, nc_lat_varid,  nc_ph_varid
  integer  :: nc_thr_varid, nc_th_varid, nc_proc_varid, nc_recnam_dimid
  integer  :: nc_recnam_varid, nc_surf_dimid
  !integer,parameter                  :: nvar=10
  character(len=16), dimension(nvar) :: varname 
  integer                            :: ivar
  integer,dimension(nvar)            :: nc_f_dimid, varlength
  
  
  varnamelist = (/'strain_dsus_sol', 'strain_dsuz_sol', 'strain_dpup_sol', &
    &             'straintrace_sol', 'strain_dsus_flu', 'strain_dsuz_flu', &
    &             'strain_dpup_flu', 'straintrace_flu', 'velo_sol       ', &
    &             'velo_flu       '/)
    
  varlength = (/nel_solid, nel_solid, nel_solid, &
                nel_solid, nel_fluid, nel_fluid, &
                nel_fluid, nel_fluid, nel_solid*2, &
                nel_solid*2/)

  varlength = varlength * (iend-ibeg+1)**2
  
  if (mynum.eq.0) then    
    write(6,*) '  Producing groups for Seismograms and Snapshots'
    call check( nf90_def_grp( ncid_out, "Seismograms", ncid_recout) )
    call check( nf90_def_grp( ncid_out, "Snapshots", ncid_snapout) )
    write(6,*) '  Seismograms group has ID', ncid_recout, ', Snapshots group has ID', ncid_snapout
    
    if (dump_wavefields) then
      write(6,*) 'Define variables in ''Snapshots'' group of NetCDF output file'
      write(6,*) '  awaiting', nstrain, ' snapshots'
      call check( nf90_def_dim( ncid=ncid_snapout, name="snapshots", len=nstrain, dimid=nc_snap_dimid) )
      call check( nf90_def_dim( ncid=ncid_snapout, name="processors", len=nproc, dimid=nc_proc_dimid) )
      do ivar=1,nvar
        call check( nf90_def_dim(ncid=ncid_snapout, name="dim_"//trim(varnamelist(ivar)),  &
                    len=varlength(ivar), dimid=nc_f_dimid(ivar)) )
        call check( nf90_def_var(ncid=ncid_snapout, name=trim(varnamelist(ivar)),&
                    xtype = NF90_FLOAT, & !deflate_level=5, &
                    dimids = (/nc_f_dimid(ivar), nc_proc_dimid, nc_snap_dimid/), varid = nc_field_varid(ivar)) )
        call check( nf90_put_att(ncid_snapout, nc_field_varid(ivar), '_FillValue', 0.0) )
        write(6,100) trim(varnamelist(ivar)), ivar, varlength(ivar), nc_field_varid(ivar)
100     format('  Netcdf variable ',A16,' with ID ', I3, ' and length', I8, ' produced.')       
      end do
    end if
    
    write(6,*) 'Define dimensions in ''Seismograms'' group of NetCDF output file'
    write(6,*) '  ''Seismograms'' group has ID ', ncid_recout
    call check( nf90_def_dim( ncid_recout, "timesteps", nsamples, nc_times_dimid) )
    call check( nf90_def_dim( ncid_recout, "receivers", nrec, nc_rec_dimid) )
    call check( nf90_def_dim( ncid_recout, "processors", nproc, nc_recproc_dimid) )
    call check( nf90_def_dim( ncid_recout, "surf_elems", maxind, nc_surf_dimid) ) 
    call check( nf90_def_dim( ncid_recout, "components", 3, nc_comp_dimid) )
    call check( nf90_def_dim( ncid_recout, "recnamlength", 40, nc_recnam_dimid) )
    write(6,*) 'NetCDF dimensions defined'
    
    write(6,*) 'Define variables in ''Seismograms'' group of NetCDF output file'
    call flush(6)
    call check( nf90_def_var( ncid_recout, "displacement", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_rec_dimid/), nc_disp_varid, &
                &  deflate_level=4) )
    call check( nf90_put_att(ncid_recout, nc_disp_varid, 'units', 'meters') )
    call check( nf90_put_att(ncid_recout, nc_disp_varid, '_FillValue', 0.0) )
    
    call check( nf90_def_var( ncid_recout, "surface_displacement", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_surf_dimid, nc_recproc_dimid/), &
                & nc_surfelem_disp_varid, deflate_level=4 ) )
    call check( nf90_put_att(ncid_recout, nc_surfelem_disp_varid, 'units', 'meters'))
    
    call check( nf90_def_var( ncid_recout, "surface_velocity", NF90_FLOAT, &
                & (/nc_times_dimid, nc_comp_dimid, nc_surf_dimid, nc_recproc_dimid/), &
                & nc_surfelem_velo_varid, deflate_level=4 ) )
    call check( nf90_put_att(ncid_recout, nc_surfelem_velo_varid, 'units', 'meters per second') )
    
    call check( nf90_def_var( ncid_recout, "Lat_req", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_latr_varid) )

    call check( nf90_def_var( ncid_recout, "Lon", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_lon_varid) )
    call check( nf90_def_var( ncid_recout, "Lat", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_lat_varid) )
    call check( nf90_def_var( ncid_recout, "azimuths", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_ph_varid) )
    call check( nf90_def_var( ncid_recout, "distances_requested", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_thr_varid) )
    call check( nf90_def_var( ncid_recout, "distances", NF90_FLOAT, &
                & (/nc_rec_dimid/), nc_th_varid) )
    call check( nf90_def_var( ncid_recout, "processor_of_receiver", NF90_INT, &
                & (/nc_rec_dimid/), nc_proc_varid) )
    call check( nf90_def_var( ncid_recout, "receiver_name", NF90_CHAR, &
                  & (/nc_rec_dimid, nc_recnam_dimid/), nc_recnam_varid) )
    write(6,*) 'NetCDF variables defined'
    call check( nf90_enddef ( ncid_out))
    write(6,*) 'Writing station info into NetCDF file'
    call check( nf90_put_var( ncid_recout, nc_th_varid, values = rec_th) )
    call check( nf90_put_var( ncid_recout, nc_ph_varid, values = rec_ph) )
    call check( nf90_put_var( ncid_recout, nc_thr_varid, values = rec_th_req) )
    call check( nf90_put_var( ncid_recout, nc_proc_varid, values = rec_proc) ) 

    !call check( nf90_put_att(ncid_out, NF90_GLOBAL, 'station names', rec_names) )
      do irec=1,nrec
        !write(6,*) 'Write name ', rec_names(irec), ' of receiver',irec
        call check( nf90_put_var( ncid_recout, nc_recnam_varid, start = (/irec, 1/),&
        &         count = (/1, 40/), &
        &         values = (rec_names(irec))) )
      end do
    write(6,*) 'done'
    call check( nf90_redef ( ncid_out))
  end if       

  allocate(recdumpvar(niter,3,nrec))

end subroutine nc_define_receiverfile


!----------------------------------------------------------------------------
subroutine define_netcdf_output
!
! Creates the netcdf output file for wavefields and defines the dimension 
! nc_1d_dimid, as unlimited.
!
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    use data_io
    use netcdf
    use data_proc, ONLY: nproc
!    use commpi
    implicit none    
!    character(len=16) nc_filename

!    nc_filename = datapath(1:lfdata)
    !if (use_netcdf) then
      write (6,*) 'Preparing netcdf file for ', nproc, ' processors'
      call check( nf90_create ( path=datapath(1:lfdata)//"/axisem_output.nc4", &
        & cmode=ior(nf90_CLOBBER,nf90_hdf5), &
        & ncid=ncid_out)) !, comm = MPI_COMM_WORLD, info = MPI_INFO_NULL)) 

      write(6,*) 'Netcdf file with ID ',ncid_out,' produced.'
    !end if
!    call check( nf90_close ( ncid_out))
end subroutine
!----------------------------------------------------------------------------

subroutine nc_write_att_char(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*), intent(in)  :: attribute_name, attribute_value
  !write(6,*) 'Writing ', attribute_value, ' to attr. ', attribute_name, ' in netcdf ID', ncid_out
  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_char

!----------------------------------------------------------------------------
subroutine nc_write_att_real(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*),  intent(in)  :: attribute_name
  real, intent(in)                :: attribute_value

  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_real

!----------------------------------------------------------------------------
subroutine nc_write_att_int(attribute_value, attribute_name)
  use netcdf
  use data_io
  character(len=*),  intent(in)  :: attribute_name
  integer, intent(in)                :: attribute_value

  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )

end subroutine nc_write_att_int

!subroutine nc_write_att_log(attribute_value, attribute_name)
!  use netcdf
!  use data_io
!  character(len=*),  intent(in)  :: attribute_name
!  logical, intent(in)                :: attribute_value
!
!  call check( nf90_put_att(ncid_out, NF90_GLOBAL, attribute_name, attribute_value) )
!
!end subroutine nc_write_att_log

subroutine nc_open_parallel
  use data_io
  use netcdf
  use data_proc 
  use commpi,      ONLY : MPI_COMM_WORLD, MPI_INFO_NULL
  use commun,      ONLY : barrier
  implicit none
  integer  status, ivar
  varnamelist = (/'strain_dsus_sol', 'strain_dsuz_sol', 'strain_dpup_sol', &
        &         'straintrace_sol', 'strain_dsus_flu', 'strain_dsuz_flu', &
        &         'strain_dpup_flu', 'straintrace_flu', 'velo_sol       ', &
        &         'velo_flu       '/)
 

  if (mynum==0) then
    call check(nf90_close(ncid_out))
    write(6,*) '  Root process closed netCDF file, waiting for all procs to arrive here and then open it for parallel IO'
  end if
  call barrier
  call check( nf90_open ( path=datapath(1:lfdata)//"/axisem_output.nc4", & 
              mode=NF90_WRITE, ncid=ncid_out, cache_size=500000000, &
              comm = MPI_COMM_WORLD, info = MPI_INFO_NULL))
  write(6,*) '  Proc ', mynum, ' opened file and is ready to rupture'
  call check( nf90_inq_grp_ncid(ncid_out, "Seismograms", ncid_recout) )
  if (dump_wavefields) then
    call check( nf90_inq_grp_ncid(ncid_out, "Snapshots", ncid_snapout) )
    do ivar = 1,nvar
      call check( nf90_inq_varid( ncid_snapout, varnamelist(ivar), nc_field_varid(ivar)) )
    end do
  end if
  call check( nf90_inq_varid( ncid_recout, "displacement", nc_disp_varid) )
  call check( nf90_inq_varid( ncid_recout, "surface_displacement", nc_surfelem_disp_varid ) )
  call check( nf90_inq_varid( ncid_recout, "surface_velocity", nc_surfelem_velo_varid ) )
   

end subroutine

!============================================================================
subroutine end_netcdf_output
! 
!  Closes the netcdf output files
!
!============================================================================
  use data_io, only: ncid_out, ncid_recout
  use netcdf
  integer  status 
  status = nf90_close(ncid_out)
!  status = nf90_close(ncid_recout)
end subroutine

!#####################################################################################
!End of S. St√§hler's netcdf routines
!#####################################################################################

end module nc_routines
